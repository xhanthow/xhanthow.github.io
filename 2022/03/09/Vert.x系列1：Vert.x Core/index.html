<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Vert.x系列1：Vert.x Core"><meta name="keywords" content="Vert.x"><meta name="author" content="anthow"><meta name="copyright" content="anthow"><title>Vert.x系列1：Vert.x Core | anthowのBlog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#In-the-beginning-there-was-Vert-x"><span class="toc-number">1.</span> <span class="toc-text">In the beginning there was Vert.x</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Specifying-options-when-creating-a-Vertx-object"><span class="toc-number">2.</span> <span class="toc-text">Specifying options when creating a Vertx object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Creating-a-clustered-Vert-x-object"><span class="toc-number">3.</span> <span class="toc-text">Creating a clustered Vert.x object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Don%E2%80%99t-call-us-we%E2%80%99ll-call-you"><span class="toc-number">4.</span> <span class="toc-text">Don’t call us, we’ll call you</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Don%E2%80%99t-block-me"><span class="toc-number">5.</span> <span class="toc-text">Don’t block me!</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reactor-and-Multi-Reactor"><span class="toc-number">6.</span> <span class="toc-text">Reactor and Multi-Reactor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Golden-Rule-Don%E2%80%99t-Block-the-Event-Loop"><span class="toc-number">7.</span> <span class="toc-text">The Golden Rule - Don’t Block the Event Loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-results"><span class="toc-number">8.</span> <span class="toc-text">Future results</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-composition"><span class="toc-number">9.</span> <span class="toc-text">Future composition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Future-coordination"><span class="toc-number">10.</span> <span class="toc-text">Future coordination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Verticles-amp-Writing-Verticles"><span class="toc-number">11.</span> <span class="toc-text">Verticles &amp; Writing Verticles</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Asynchronous-Verticle-start-and-stop"><span class="toc-number">12.</span> <span class="toc-text">Asynchronous Verticle start and stop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Verticle-Types"><span class="toc-number">13.</span> <span class="toc-text">Verticle Types</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Standard-verticles"><span class="toc-number">13.1.</span> <span class="toc-text">Standard verticles</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Worker-verticles"><span class="toc-number">13.2.</span> <span class="toc-text">Worker verticles</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deploying-Undeploying-verticles-programmatically"><span class="toc-number">14.</span> <span class="toc-text">Deploying&#x2F;Undeploying verticles programmatically</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-are-Verticle-Factories-located"><span class="toc-number">15.</span> <span class="toc-text">How are Verticle Factories located?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Waiting-for-deployment-to-complete"><span class="toc-number">16.</span> <span class="toc-text">Waiting for deployment to complete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Passing-configuration-to-a-verticle"><span class="toc-number">17.</span> <span class="toc-text">Passing configuration to a verticle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Context-object"><span class="toc-number">18.</span> <span class="toc-text">The Context object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executing-periodic-and-delayed-actions"><span class="toc-number">19.</span> <span class="toc-text">Executing periodic and delayed actions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Event-Bus"><span class="toc-number">20.</span> <span class="toc-text">The Event Bus</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Addressing"><span class="toc-number">20.1.</span> <span class="toc-text">Addressing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Handlers"><span class="toc-number">20.2.</span> <span class="toc-text">Handlers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Publish-subscribe-messaging"><span class="toc-number">20.3.</span> <span class="toc-text">Publish &#x2F; subscribe messaging</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Point-to-point-and-Request-Response-messaging"><span class="toc-number">20.4.</span> <span class="toc-text">Point-to-point and Request-Response messaging</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Best-effort-delivery"><span class="toc-number">20.5.</span> <span class="toc-text">Best-effort delivery</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Event-Bus-API"><span class="toc-number">21.</span> <span class="toc-text">The Event Bus API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Getting-the-event-bus"><span class="toc-number">21.1.</span> <span class="toc-text">Getting the event bus</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Registering-Handlers"><span class="toc-number">21.2.</span> <span class="toc-text">Registering Handlers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Publishing-messages"><span class="toc-number">21.3.</span> <span class="toc-text">Publishing messages</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sending-messages"><span class="toc-number">21.4.</span> <span class="toc-text">Sending messages</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Acknowledging-messages-sending-replies"><span class="toc-number">21.5.</span> <span class="toc-text">Acknowledging messages &#x2F; sending replies</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clustered-Event-Bus"><span class="toc-number">22.</span> <span class="toc-text">Clustered Event Bus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffers"><span class="toc-number">23.</span> <span class="toc-text">Buffers</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Creating-buffers"><span class="toc-number">23.1.</span> <span class="toc-text">Creating buffers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Writing-to-a-Buffer"><span class="toc-number">23.2.</span> <span class="toc-text">Writing to a Buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reading-from-a-Buffer"><span class="toc-number">23.3.</span> <span class="toc-text">Reading from a Buffer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Writing-TCP-servers-and-clients"><span class="toc-number">24.</span> <span class="toc-text">Writing TCP servers and clients</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Creating-a-TCP-server"><span class="toc-number">24.1.</span> <span class="toc-text">Creating a TCP server</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Scaling-sharing-TCP-servers"><span class="toc-number">24.2.</span> <span class="toc-text">Scaling - sharing TCP servers</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Creating-a-TCP-client"><span class="toc-number">24.3.</span> <span class="toc-text">Creating a TCP client</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Logging-network-activity"><span class="toc-number">24.4.</span> <span class="toc-text">Logging network activity</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Specifying-key-certificate-for-the-server"><span class="toc-number">24.5.</span> <span class="toc-text">Specifying key&#x2F;certificate for the server</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Self-signed-certificates-for-testing-and-development-purposes"><span class="toc-number">24.6.</span> <span class="toc-text">Self-signed certificates for testing and development purposes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Revoking-certificate-authorities"><span class="toc-number">24.7.</span> <span class="toc-text">Revoking certificate authorities</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Using-a-proxy-for-client-connections"><span class="toc-number">24.8.</span> <span class="toc-text">Using a proxy for client connections</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Writing-HTTP-servers-and-clients"><span class="toc-number">25.</span> <span class="toc-text">Writing HTTP servers and clients</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Creating-an-HTTP-Server"><span class="toc-number">25.1.</span> <span class="toc-text">Creating an HTTP Server</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Start-the-Server-Listening"><span class="toc-number">25.2.</span> <span class="toc-text">Start the Server Listening</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Getting-notified-of-incoming-requests"><span class="toc-number">25.3.</span> <span class="toc-text">Getting notified of incoming requests</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Reading-Data-from-the-Request-Body"><span class="toc-number">25.4.</span> <span class="toc-text">Reading Data from the Request Body</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Handling-HTML-forms"><span class="toc-number">25.5.</span> <span class="toc-text">Handling HTML forms</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Handling-form-file-uploads"><span class="toc-number">25.6.</span> <span class="toc-text">Handling form file uploads</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Handling-cookies"><span class="toc-number">25.7.</span> <span class="toc-text">Handling cookies</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Handling-responses"><span class="toc-number">25.8.</span> <span class="toc-text">Handling responses</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Serving-files-directly-from-disk-or-the-classpath"><span class="toc-number">25.9.</span> <span class="toc-text">Serving files directly from disk or the classpath</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://z3.ax1x.com/2021/04/03/cn78Y9.jpg"></div><div class="author-info__name text-center">anthow</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/xhanthow">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">anthowのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Blog</a><a class="site-page" href="/archives">Posts</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Vert.x系列1：Vert.x Core</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Vert-x%E7%B3%BB%E5%88%97/"> Vert.x系列</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7k</span><span class="post-meta__separator">|</span><span>Reading time: 28 min</span></span></div><div class="article-container" id="post-content"><blockquote>
<p><code>Vert.x Core</code>：<a target="_blank" rel="noopener" href="https://vertx.io/docs/vertx-core/java/">官方文档</a></p>
</blockquote>
<p>去年就想好好研究下<code>Vert.x</code>的，但是由于懒，计划就一直搁浅了，今年就立个flag，认认真真研究下<code>Vert.x</code>，并在该博客下输出。</p>
<p>作为起步，就从<code>Vert.x Core</code>的官方文档开始，记录下各个章节中比较重点的内容，有些章节的顺序也会做调整或者直接删除了…</p>
<span id="more"></span>

<h4 id="In-the-beginning-there-was-Vert-x"><a href="#In-the-beginning-there-was-Vert-x" class="headerlink" title="In the beginning there was Vert.x"></a>In the beginning there was Vert.x</h4><p>在<code>Vert.x</code>世界里，<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/Vertx.html">Vertx</a>对象就是“一等公民”，是几乎所有操作的基础（可以点开API具体看看）。可以使用如下的方式创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx();</span><br></pre></td></tr></table></figure>

<p>最终还是会委托到<code>VertxImpl</code>上来创建<code>Vertx</code>对象，可以先眼熟下继承关系。后续也会重点分析[挖坑1]</p>
<p>![](Vert.x系列1：Vert.x Core/vertx继承关系.png)</p>
<h4 id="Specifying-options-when-creating-a-Vertx-object"><a href="#Specifying-options-when-creating-a-Vertx-object" class="headerlink" title="Specifying options when creating a Vertx object"></a>Specifying options when creating a Vertx object</h4><p>上面我们创建<code>Vertx</code>对象的时候，用的都是默认配置<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/VertxOptions.html">VertxOptions</a>，作者贴心为我们提供了很多参数的默认值，我们也可以传入指定的参数来创建<code>Vertx</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vertx vertx = Vertx.vertx(<span class="keyword">new</span> VertxOptions().setWorkerPoolSize(<span class="number">40</span>));</span><br></pre></td></tr></table></figure>

<h4 id="Creating-a-clustered-Vert-x-object"><a href="#Creating-a-clustered-Vert-x-object" class="headerlink" title="Creating a clustered Vert.x object"></a>Creating a clustered Vert.x object</h4><p>如果想要以集群的方式创建<code>Vertx</code>，因为对于群集中的不同<code>Vertx</code>实例组合在一起会花费一定时间，我们又不想去阻塞调用线程，那么就需要以另一种异步的方式来创建<code>Vertx</code>对象。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vertx.clusteredVertx(<span class="keyword">new</span> VertxOptions(), res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    <span class="comment">// 获取集群模式下的Vertx对象</span></span><br><span class="line">    Vertx vertx = res.result();</span><br><span class="line">    <span class="comment">// success logic</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fail logic</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Don’t-call-us-we’ll-call-you"><a href="#Don’t-call-us-we’ll-call-you" class="headerlink" title="Don’t call us, we’ll call you"></a>Don’t call us, we’ll call you</h4><blockquote>
<p>俗称“好莱坞原则”</p>
</blockquote>
<p><code>Vert.x</code>提供的<code>API</code>大多都是事件驱动的，事件发生时会触发回调。如下：</p>
<ul>
<li>一个定时器被触发</li>
<li><code>Socket</code>收到了一些数据</li>
<li>从磁盘中读取了一些数据</li>
<li>发生了异常</li>
<li>HTTP服务器收到了请求</li>
</ul>
<p>如定时器触发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vertx.setPeriodic(<span class="number">1000</span>, id -&gt; &#123;</span><br><span class="line">  <span class="comment">// 该回调逻辑每秒触发一次</span></span><br><span class="line">  System.out.println(<span class="string">&quot;timer fired!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如服务器收到请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vertx.createHttpServer().requestHandler(request -&gt; &#123;</span><br><span class="line">  <span class="comment">// 服务器每收到一个请求，该回调逻辑将被调用</span></span><br><span class="line">  request.response().end(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>事件到来时，<code>Vert.x</code>程序会异步调用这里的<code>Handler</code>逻辑（回调逻辑）`！！！</p>
<h4 id="Don’t-block-me"><a href="#Don’t-block-me" class="headerlink" title="Don’t block me!"></a>Don’t block me!</h4><p>这就是<code>Vert.x</code>的精髓！！！我们知道如果任务都是立马可以执行完毕，这样我们用少量的线程就可以执行大量的任务，少量的线程意味着所需的内存（线程栈需要消耗内存）会减小，也不会产生大量的上下文切换。所以<code>Vert.x</code>中除了很少的特例（如以 <code>Sync</code> 结尾的某些文件系统操作）以外，它的API都不会阻塞线程。</p>
<p>如果操作不能立马返回结果，我们就需要提供一个处理器（<code>Handler</code>）来接受回调事件。</p>
<p>当使用传统的阻塞式API做以下操作时，调用线程可能会被阻塞：</p>
<ul>
<li>从<code>Socket</code>中读取数据</li>
<li>写数据到磁盘</li>
<li>发送消息给接收者并等待回复</li>
<li>……</li>
</ul>
<p>由于这个时候线程是阻塞的，所以要处理大量并发就要大量线程，随之而来的就是内存和上下文切换带来的开销，这样程序也是难以扩展的。</p>
<h4 id="Reactor-and-Multi-Reactor"><a href="#Reactor-and-Multi-Reactor" class="headerlink" title="Reactor and Multi-Reactor"></a>Reactor and Multi-Reactor</h4><p>从前面我们可以了解到<code>Vert.x</code>的API都是事件驱动的，当有事件过来的时候，<code>Vert.x</code>使用被称为 <strong>EventLoop</strong> 的线程来调用事件处理器。由于没有阻塞，<strong>EventLoop</strong> 可在短时间内分发大量的事件。例如，一个单独的 <strong>EventLoop</strong> 可以非常迅速地处理数千个 HTTP 请求。我们称之为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reactor_pattern"><code>Reactor</code>模式</a>，<code>Node.js</code>也使用了该模式。</p>
<p>在标准的<code>Reactor</code>实现中，有 <strong>一个独立的EventLoop</strong> 会循环执行，处理所有到达的事件并传递给处理器处理。单一线程的问题就是只能在一个核上运行，如果希望利用到多核，则需要启动不同的进程。但是<code>Vert.x</code>工作模式是一个<code>Vertx</code>实例维护着多个<strong>EventLoop</strong>线程，默认情况会根据机器上可用核的数量来设置，不过我们也可以自行设置。我们将这种模式称为 <strong>Multi-Reactor 模式</strong>（多反应器模式），区别于单线程的 Reactor 模式（反应器模式）。</p>
<blockquote>
<p>即使一个 <code>Vertx</code> 实例维护了多个EventLoop，任何一个特定的处理器永远不会被并发执行。大部分情况下（除了 <a target="_blank" rel="noopener" href="http://vertx.io/docs/vertx-core/java/#worker_verticles">Worker Verticle</a> 以外）它们总是在同一个EventLoop线程中被调用。</p>
</blockquote>
<h4 id="The-Golden-Rule-Don’t-Block-the-Event-Loop"><a href="#The-Golden-Rule-Don’t-Block-the-Event-Loop" class="headerlink" title="The Golden Rule - Don’t Block the Event Loop"></a>The Golden Rule - Don’t Block the Event Loop</h4><p><code>Vert.x</code>提供的APi大多都是非阻塞的并且不会阻塞EventLoop线程，但是这并不能阻止我们在<code>Handler</code>中产生阻塞操作。如果我们在<code>Handler</code>中有阻塞操作，那么EventLoop线程也会被无情的阻塞住，那么<code>Vert.x</code>的世界就会崩塌。就像你去排队叫号点餐， 你前面的人拿到号却不走了，一直耗在这儿，那后面的人不得揍他啊。</p>
<p>所以<strong>千万不要阻塞EventLoop线程</strong>，这些阻塞的做法包括：</p>
<ul>
<li><code>Thead.sleep()</code></li>
<li>等待一个锁</li>
<li>等待一个互斥信号或监视器（例如同步的代码块）</li>
<li>执行一个长时间数据库操作并等待其结果</li>
<li>执行一个复杂的计算，占用了可感知的时长</li>
</ul>
<p>还好<code>Vert.x</code>有一套监控机制，如果在日志中发现有如下警告：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</span><br></pre></td></tr></table></figure>

<p>那么一定要审视自己的程序！</p>
<h4 id="Future-results"><a href="#Future-results" class="headerlink" title="Future results"></a>Future results</h4><p><code>Vert.x</code>使用<code>futures</code>来表示一个异步的结果（一个异步的方法会返回<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/Future.html"><code>Future</code></a>对象来表示结果）</p>
<p>我们在使用时，也不要直接去和<code>future</code>交互，而是利用回调来玩。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fs = vertx.fileSystem();</span><br><span class="line"></span><br><span class="line">Future&lt;FileProps&gt; future = fs.props(<span class="string">&quot;/my_file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">future.onComplete((AsyncResult&lt;FileProps&gt; ar) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    FileProps props = ar.result();</span><br><span class="line">    System.out.println(<span class="string">&quot;File size = &quot;</span> + props.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Failure: &quot;</span> + ar.cause().getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Future-composition"><a href="#Future-composition" class="headerlink" title="Future composition"></a>Future composition</h4><p>和<code>CompletableFuture</code>玩法差不多，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fs = vertx.fileSystem();</span><br><span class="line"></span><br><span class="line">Future&lt;Void&gt; future = fs</span><br><span class="line">  .createFile(<span class="string">&quot;/foo&quot;</span>)</span><br><span class="line">  .compose(v -&gt; &#123;</span><br><span class="line">    <span class="comment">// When the file is created (fut1), execute this:</span></span><br><span class="line">    <span class="keyword">return</span> fs.writeFile(<span class="string">&quot;/foo&quot;</span>, Buffer.buffer());</span><br><span class="line">  &#125;)</span><br><span class="line">  .compose(v -&gt; &#123;</span><br><span class="line">    <span class="comment">// When the file is written (fut2), execute this:</span></span><br><span class="line">    <span class="keyword">return</span> fs.move(<span class="string">&quot;/foo&quot;</span>, <span class="string">&quot;/bar&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面会产生3个<code>Future</code>：</p>
<ol>
<li>创建文件</li>
<li>向文件中写入内容</li>
<li>移除文件</li>
</ol>
<p>只有这3个<code>Future</code>的结果都是成功的，这整个“链条”才是成功的，只要有任一个失败，则结果就是失败的。除了<code>compose</code>操作，还可以进行<code>map</code>、<code>recover</code>、 <code>otherwise</code> 、<code>flatMap</code>等操作。</p>
<h4 id="Future-coordination"><a href="#Future-coordination" class="headerlink" title="Future coordination"></a>Future coordination</h4><p>在<code>Vert.x</code>中可以协调多个<code>future</code>，即可以并行组合也可以穿行。如<code>CompositeFuture.all</code>，最多可以接受6个<code>future</code>，只有所有的<code>future</code>的结果都成功，<code>CompositeFuture.all</code>才返回成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;HttpServer&gt; httpServerFuture = httpServer.listen();</span><br><span class="line"></span><br><span class="line">Future&lt;NetServer&gt; netServerFuture = netServer.listen();</span><br><span class="line"></span><br><span class="line">CompositeFuture.all(httpServerFuture, netServerFuture).onComplete(ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    <span class="comment">// All servers started</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// At least one server failed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>还有<code>CompositeFuture.any</code>、<code>CompositeFuture.join</code>操作…</p>
<h4 id="Verticles-amp-Writing-Verticles"><a href="#Verticles-amp-Writing-Verticles" class="headerlink" title="Verticles &amp; Writing Verticles"></a>Verticles &amp; Writing Verticles</h4><p><code>Verticles</code>的代码块是被<code>Vert.x</code>部署和运行的，一般业务逻辑都是运行于此。应用程序通常由许多运行在同一<code>Vert.x</code>实例中的<code>Verticle</code>组成，各个<code>Verticle</code>通过<code>event bus</code>来发送消息交流。</p>
<p>一般通过继承<code>AbstractVerticle</code>来实现自己的<code>Verticle</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Called when verticle is deployed</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Optional - called when verticle is undeployed</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>Vert.x</code>部署<code>Verticle</code>时，会执行<code>start()</code>方法，<strong>通常我们也会重写<code>start()</code>方法</strong>，<code>start()</code>方法执行完，可以认为该<code>Verticle</code>已经启动。</p>
<p>当<code>Vert.x</code>卸载<code>Verticle</code>时，会执行<code>stop()</code>方法，我们也可以选择复写<code>stop()</code>方法，<code>stop()</code>方法执行完，可以认为该<code>Verticle</code>已经停止。</p>
<h4 id="Asynchronous-Verticle-start-and-stop"><a href="#Asynchronous-Verticle-start-and-stop" class="headerlink" title="Asynchronous Verticle start and stop"></a>Asynchronous Verticle start and stop</h4><p>如果<code>start()</code>会很耗时，当然我们也不想阻塞在这里，就可以使用异步版的<code>start()</code>方法，该方法会提供一个<code>Future</code>作为参数，这个时候如果执行完<code>start()</code>方法后，并不会认为该<code>Verticle</code>部署成功：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> HttpServer server;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Promise&lt;Void&gt; startPromise)</span> </span>&#123;</span><br><span class="line">   server = vertx.createHttpServer().requestHandler(req -&gt; &#123;</span><br><span class="line">     req.response()</span><br><span class="line">       .putHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">       .end(<span class="string">&quot;Hello from Vert.x!&quot;</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now bind the server:</span></span><br><span class="line">   server.listen(<span class="number">8080</span>, res -&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">       startPromise.complete();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       startPromise.fail(res.cause());</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步<code>stop()</code>和异步<code>start()</code>类似。</p>
<h4 id="Verticle-Types"><a href="#Verticle-Types" class="headerlink" title="Verticle Types"></a>Verticle Types</h4><h5 id="Standard-verticles"><a href="#Standard-verticles" class="headerlink" title="Standard verticles"></a>Standard verticles</h5><p>这是最常用也是最有用的类型，它总是在EventLoop线程中执行。当Standard Verticle被创建时，它会被分派给一个EventLoop线程，并在这个EventLoop中执行它的 <code>start</code> 方法。当在一个EventLoop上调用了Core API中的方法并传入了处理器时，<code>Vert.x</code>将保证它们都是在同一个EventLoop线程中执行，这也意味着，我们Verticle中的所有代码都是在<strong>相同的EventLoop线程中执行</strong>，即可以用单线程的方式来编写程序。</p>
<h5 id="Worker-verticles"><a href="#Worker-verticles" class="headerlink" title="Worker verticles"></a>Worker verticles</h5><p>Worker Verticle是在由<code>Vert.x</code>提供的worker线程池中执行而不是在EventLoop线程中执行，它被设计用来执行阻塞的操作，Worker Verticle实例不会在<code>Vert.x</code>中被多个线程同时执行，但它可以在不同时间由不同线程执行。</p>
<p>如果想部署worker verticle，如下设置即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setWorker(<span class="keyword">true</span>);</span><br><span class="line">vertx.deployVerticle(<span class="string">&quot;com.mycompany.MyOrderProcessorVerticle&quot;</span>, options);</span><br></pre></td></tr></table></figure>

<h4 id="Deploying-Undeploying-verticles-programmatically"><a href="#Deploying-Undeploying-verticles-programmatically" class="headerlink" title="Deploying/Undeploying verticles programmatically"></a>Deploying/Undeploying verticles programmatically</h4><p>使用<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/Vertx.html#deployVerticle-io.vertx.core.Verticle-">deployVerticle</a>方法，即可以传Verticle名称也可以传Verticle实力本身。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以实例方式部署</span></span><br><span class="line">Verticle myVerticle = <span class="keyword">new</span> MyVerticle();</span><br><span class="line">vertx.deployVerticle(myVerticle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以名称方式部署：通过VerticleFactory,找到对应的实例，并初始化，最终还是调用该方法：io.vertx.core.impl.DeploymentManager#doDeploy</span></span><br><span class="line">Verticle myVerticle = <span class="keyword">new</span> MyVerticle();</span><br><span class="line">vertx.deployVerticle(<span class="string">&quot;com.anthow.myVerticle&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="How-are-Verticle-Factories-located"><a href="#How-are-Verticle-Factories-located" class="headerlink" title="How are Verticle Factories located?"></a>How are Verticle Factories located?</h4><p>可以调用<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/Vertx.html#registerVerticleFactory-io.vertx.core.spi.VerticleFactory-">registerVerticleFactory</a>方法，调用点如下：</p>
<ul>
<li>io.vertx.core.impl.VertxImpl#registerVerticleFactory（用代码形式，手动调用）</li>
<li>io.vertx.core.impl.VerticleManager#loadVerticleFactories（可以通过SPI方式自定义VerticleFactory）</li>
</ul>
<blockquote>
<p>拓展性非常好，设计方法值得借鉴</p>
</blockquote>
<h4 id="Waiting-for-deployment-to-complete"><a href="#Waiting-for-deployment-to-complete" class="headerlink" title="Waiting for deployment to complete"></a>Waiting for deployment to complete</h4><p>部署Verticle是异步的，等<code>deployVerticle()</code>方法结果返回可能会耗费一定时间，我们仍然可以使用事件处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vertx.deployVerticle(<span class="string">&quot;com.anthow.myVerticle&quot;</span>, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Deployment id is: &quot;</span> + res.result());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Deployment failed!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果部署成功，<code>res</code>中会返回<code>deploymentID</code>，如果需要卸载Verticle的话，可以用到！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vertx.undeploy(deploymentID, res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Undeployed ok&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Undeploy failed!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Passing-configuration-to-a-verticle"><a href="#Passing-configuration-to-a-verticle" class="headerlink" title="Passing configuration to a verticle"></a>Passing configuration to a verticle</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JsonObject config = <span class="keyword">new</span> JsonObject().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;tim&quot;</span>).put(<span class="string">&quot;directory&quot;</span>, <span class="string">&quot;/blah&quot;</span>);</span><br><span class="line"><span class="comment">// 可以通过setInstances来设置verticle的数量，来充分利用cpu核数</span></span><br><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setConfig(config).setInstances(<span class="number">16</span>);</span><br><span class="line">vertx.deployVerticle(verticle, options);</span><br></pre></td></tr></table></figure>

<p>设置了配置之后，可以在verticle中通过<code>config()</code>方法来获取。</p>
<h4 id="The-Context-object"><a href="#The-Context-object" class="headerlink" title="The Context object"></a>The Context object</h4><p>![](/Vert.x系列1：Vert.x Core/context继承管理.png)</p>
<p>如果在<code>Vert.x</code>中使用了事件处理器或者调用了verticle的<code>start()</code>或者<code>stop()</code>方法，就会关联一个<code>context</code>，通常这个<code>context</code>是<strong>EventLoopContext</strong>而且绑定了一个EventLoop线程。所以在这个<code>context</code>执行代码时，都会在同一个EventLoop线程中。如果是worker verticle时，会关联一个<strong>WorkerContext</strong>，并且所有的操作运都会运行在 Worker线程池的线程上。<br>获取<code>context</code>方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Context context = vertx.getOrCreateContext();</span><br></pre></td></tr></table></figure>

<p>如果一个<code>context</code>已经绑定了一个线程，那么可以复用这个<code>context</code>对象，不然就新建一个<code>context</code>对象。</p>
<p>可以通过以下方式获取context的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Context context = vertx.getOrCreateContext();</span><br><span class="line"><span class="keyword">if</span> (context.isEventLoopContext()) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Context attached to Event Loop&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isWorkerContext()) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Context attached to Worker Thread&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (! Context.isOnVertxThread()) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Context not attached to a thread managed by vert.x&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当获取到了context对象后， 便可以在context中异步执行代码了，提交的任务也会在同一个context中运行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vertx.getOrCreateContext().runOnContext( (v) -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;This will be executed asynchronously in the same context&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果在context中执行了多个函数，也可以通过context来共享数据:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Context context = vertx.getOrCreateContext();</span><br><span class="line">context.put(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">context.runOnContext((v) -&gt; &#123;</span><br><span class="line">  String hello = context.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Executing-periodic-and-delayed-actions"><a href="#Executing-periodic-and-delayed-actions" class="headerlink" title="Executing periodic and delayed actions"></a>Executing periodic and delayed actions</h4><p>单次执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setTimer(<span class="number">1000</span>, id -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;And one second later this is printed&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;First this is printed&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>周期性执行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> timerID = vertx.setPeriodic(<span class="number">1000</span>, id -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;And every second this is printed&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;First this is printed&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：定时任务可能是个耗时操作，所以计时器事件可能会连续执行甚至产生堆积，所以建议用<code>setTimer()</code>方法，当任务执行完成时设置下一个计时器。</p>
</blockquote>
<p>取消定时器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vertx.cancelTimer(timerID);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在verticle创建了定时器，当verticle被undeployed时，该定时器会自动被取消掉</p>
</blockquote>
<h4 id="The-Event-Bus"><a href="#The-Event-Bus" class="headerlink" title="The Event Bus"></a>The Event Bus</h4><p>Event Bus是<code>Vert.x</code>的神经系统。每一个<code>Vert.x</code>实例都有一个单独的Event Bus实例。可以通过 <code>Vertx</code> 实例的 <a target="_blank" rel="noopener" href="http://vertx.io/docs/apidocs/io/vertx/core/Vertx.html#eventBus--"><code>eventBus</code></a> 方法来获得对应的 <code>EventBus</code> 实例。</p>
<h5 id="Addressing"><a href="#Addressing" class="headerlink" title="Addressing"></a>Addressing</h5><p>消息会被Event Bus发送到一个地址，<code>Vert.x</code>对地址的格式没有要求，只要是个字符串即可，但是用的时候最好还是有一定的规则。</p>
<h5 id="Handlers"><a href="#Handlers" class="headerlink" title="Handlers"></a>Handlers</h5><p>消息会被处理器（handler）接受，处理器可以注册到一个地址上，处理器和地址之间的关系是多对多的。</p>
<h5 id="Publish-subscribe-messaging"><a href="#Publish-subscribe-messaging" class="headerlink" title="Publish / subscribe messaging"></a>Publish / subscribe messaging</h5><p>Event Bus支持发布订阅模式，即向一个地址发送消息，然后所有注册了该地址的处理器都会收到通知。</p>
<h5 id="Point-to-point-and-Request-Response-messaging"><a href="#Point-to-point-and-Request-Response-messaging" class="headerlink" title="Point-to-point and Request-Response messaging"></a>Point-to-point and Request-Response messaging</h5><p>Event Bus也支持点对点模式，消息被发送到一个地址上，然后<code>Vert.x</code>会采用<strong>不严格的轮询算法</strong>选择一个处理器。</p>
<p>也可在消息发送的时候，指定一个应答处理器，接受者在接收到消息时，可以选择回复该消息，若回复消息则应答处理器会被调用，发送者收到回复消息后，也可以选择应答，这2个过程可以不断重复下去。可以看做是<strong>请求-应答</strong>模式。</p>
<h5 id="Best-effort-delivery"><a href="#Best-effort-delivery" class="headerlink" title="Best-effort delivery"></a>Best-effort delivery</h5><p><code>Vert.x</code>会尽它最大努力去传递消息，并且不会主动丢弃消息，但是当Event Bus中的全部或部分发生故障时，则可能会丢失消息。若应用关心丢失的消息，就得编写具有幂等性的处理器，并且发送者可以在恢复后重试。</p>
<h4 id="The-Event-Bus-API"><a href="#The-Event-Bus-API" class="headerlink" title="The Event Bus API"></a>The Event Bus API</h4><h5 id="Getting-the-event-bus"><a href="#Getting-the-event-bus" class="headerlink" title="Getting the event bus"></a>Getting the event bus</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br></pre></td></tr></table></figure>

<h5 id="Registering-Handlers"><a href="#Registering-Handlers" class="headerlink" title="Registering Handlers"></a>Registering Handlers</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus eb = vertx.eventBus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个consumer又可以做很多事情...具体看API,如下面的取消注册</span></span><br><span class="line">MessageConsumer&lt;String&gt; consumer = eb.consumer(<span class="string">&quot;news.uk.sport&quot;</span>, message -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;I have received a message: &quot;</span> + message.body());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.unregister(res -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;The handler un-registration has reached all nodes&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Un-registration failed!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Publishing-messages"><a href="#Publishing-messages" class="headerlink" title="Publishing messages"></a>Publishing messages</h5><p>发布订阅模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eventBus.publish(<span class="string">&quot;news.uk.sport&quot;</span>, <span class="string">&quot;Yay! Someone kicked a ball&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Sending-messages"><a href="#Sending-messages" class="headerlink" title="Sending messages"></a>Sending messages</h5><p>点对点模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eventBus.send(<span class="string">&quot;news.uk.sport&quot;</span>, <span class="string">&quot;Yay! Someone kicked a ball&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Acknowledging-messages-sending-replies"><a href="#Acknowledging-messages-sending-replies" class="headerlink" title="Acknowledging messages / sending replies"></a>Acknowledging messages / sending replies</h5><p>接受者发送回应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageConsumer&lt;String&gt; consumer = eventBus.consumer(<span class="string">&quot;news.uk.sport&quot;</span>);</span><br><span class="line">consumer.handler(message -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;I have received a message: &quot;</span> + message.body());</span><br><span class="line">  message.reply(<span class="string">&quot;how interesting!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>接受者接受回应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eventBus.request(<span class="string">&quot;news.uk.sport&quot;</span>, <span class="string">&quot;Yay! Someone kicked a ball across a patch of grass&quot;</span>, ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received reply: &quot;</span> + ar.result().body());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/msbadar/vertx-eventbus">Event Bus例子</a></p>
<h4 id="Clustered-Event-Bus"><a href="#Clustered-Event-Bus" class="headerlink" title="Clustered Event Bus"></a>Clustered Event Bus</h4><blockquote>
<p>依赖<code>ClusteredVertx</code>的相关知识</p>
</blockquote>
<h4 id="Buffers"><a href="#Buffers" class="headerlink" title="Buffers"></a>Buffers</h4><p>在<code>Vert.x</code>中大部分数据被重新组织成<code>Buffer</code> 。一个 <code>Buffer</code> 是可以读取或写入的0个或多个字节序列，并且根据需要可以自动扩容、将任意字节写入 <code>Buffer</code>，也可以将 <code>Buffer</code> 想象成字节数组。</p>
<blockquote>
<p>其底层使用了netty的<code>ByteBuf</code></p>
</blockquote>
<h5 id="Creating-buffers"><a href="#Creating-buffers" class="headerlink" title="Creating buffers"></a>Creating buffers</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空的buffer</span></span><br><span class="line">Buffer buff = Buffer.buffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串创建一个buffer,默认使用UTF-8编码</span></span><br><span class="line">Buffer buff = Buffer.buffer(<span class="string">&quot;some string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定编码</span></span><br><span class="line">Buffer buff = Buffer.buffer(<span class="string">&quot;some string&quot;</span>, <span class="string">&quot;UTF-16&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字节数组创建buffer</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Buffer buff = Buffer.buffer(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小，类似java中的数组指定大小一样，这样不用重新调整大小，效率更高。</span></span><br><span class="line"><span class="comment">// 但是这个时候，buff是空的，而不是用0填充</span></span><br><span class="line">Buffer buff = Buffer.buffer(<span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Writing-to-a-Buffer"><a href="#Writing-to-a-Buffer" class="headerlink" title="Writing to a Buffer"></a>Writing to a Buffer</h5><p>有2种方式往buffer中写入数据：追加和随机写入，写入时都会自动扩容，所以不会出现<code>IndexOutOfBoundsException</code>的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 追加写</span></span><br><span class="line">Buffer buff = Buffer.buffer();</span><br><span class="line">buff.appendInt(<span class="number">123</span>).appendString(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">socket.write(buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机写，根据需要进行自动扩容</span></span><br><span class="line">Buffer buff = Buffer.buffer();</span><br><span class="line">buff.setInt(<span class="number">1000</span>, <span class="number">123</span>);</span><br><span class="line">buff.setString(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Reading-from-a-Buffer"><a href="#Reading-from-a-Buffer" class="headerlink" title="Reading from a Buffer"></a>Reading from a Buffer</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer buff = Buffer.buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buff.length(); i += <span class="number">4</span>) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;int value at &quot;</span> + i + <span class="string">&quot; is &quot;</span> + buff.getInt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Writing-TCP-servers-and-clients"><a href="#Writing-TCP-servers-and-clients" class="headerlink" title="Writing TCP servers and clients"></a>Writing TCP servers and clients</h4><p>使用<code>Vert.x</code>可以很轻松的编写出非阻塞的TCP客户端和服务端。</p>
<h5 id="Creating-a-TCP-server"><a href="#Creating-a-TCP-server" class="headerlink" title="Creating a TCP server"></a>Creating a TCP server</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用配置也可以不使用</span></span><br><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().setPort(<span class="number">4321</span>);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要设置connectHandler，不然会报错</span></span><br><span class="line">vertx.createNetServer().connectHandler(netSocket -&gt; &#123;</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    netSocket.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    netSocket.handler(buffer -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I received some bytes: &quot;</span> + buffer.length());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 连接关闭</span></span><br><span class="line">    netSocket.closeHandler(res -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>, res -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server is now listening!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Failed to bind!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>connectHandler</code>：每次建立连接的时候会触发一次</li>
<li><code>netSocket.write</code>：异步写入</li>
<li><code>netSocket.handler</code>：当收到请求时会触发一次</li>
<li><code>netSocket.closeHandler</code>：连接关闭触发</li>
</ul>
<blockquote>
<p><code>NetSocket</code>还有很多其他方法，如<code>writeHandlerID</code>，<code>localAddress</code>，<code>remoteAddress</code></p>
</blockquote>
<p>当想要发送文件也是很高效方便（可以被操作系统内核直接处理），直接调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">netSocket.sendFile(<span class="string">&quot;myfile.dat&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Scaling-sharing-TCP-servers"><a href="#Scaling-sharing-TCP-servers" class="headerlink" title="Scaling - sharing TCP servers"></a>Scaling - sharing TCP servers</h5><p>上述中的<code>connectHandler</code>方法都是在同一个<code>EventLoop</code>线程中执行的，所以如果我们在多核的服务器上运行的话，就只能利用其一个核心了，想要利用多核的话，可以用如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 部署的时候Instances可以设置大于1</span></span><br><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setInstances(<span class="number">10</span>);</span><br><span class="line">vertx.deployVerticle(<span class="string">&quot;com.mycompany.MyVerticle&quot;</span>, options);</span><br></pre></td></tr></table></figure>

<p>但是还有个神奇的地方，如果创建多个<code>NetServer</code>，然后监听同一个端口，按照常理来说肯定会出现端口冲突的问题，但是<code>Vert.x</code>在内部做了一个处理，就是发现有重复的端口的时候，会加入到一个列表中。代码可以参考这部分：<code>io.vertx.core.net.impl.TCPServerBase#listen</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">	NetServer netServer = vertx.createNetServer();</span><br><span class="line">	<span class="keyword">int</span> num = i;</span><br><span class="line">	netServer.connectHandler(socket -&gt; &#123;</span><br><span class="line">		socket.handler(buffer -&gt; &#123;</span><br><span class="line">			System.out.println(num);</span><br><span class="line">			System.out.println(Thread.currentThread());</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">	netServer.listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们部署时，<code>instances</code>数量大于1，然后我们又创建了多个<code>NetServer</code>（如上），可以在本地测试下，就会发现<code>com.mycompany.MyVerticle</code>运行在不同的EventLoop线程中，创建的多个<code>NetServer</code>它们都运行在同一个EventLoop线程中。</p>
<h5 id="Creating-a-TCP-client"><a href="#Creating-a-TCP-client" class="headerlink" title="Creating a TCP client"></a>Creating a TCP client</h5><p>和创建TCP Server类似，创建TCP Client也是很方便的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认配置</span></span><br><span class="line">NetClient client = vertx.createNetClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定配置</span></span><br><span class="line">NetClientOptions options = <span class="keyword">new</span> NetClientOptions().setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">NetClient client = vertx.createNetClient(options);</span><br></pre></td></tr></table></figure>

<p>和服务器建立连接：</p>
<p>获取<code>NetClient</code>后，可以调用<code>connect</code>方法，传入ip、post以及Handler（如果连接成功，可以从result中获取NetSocket，然后执行后续业务逻辑）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetClient netClient = vertx.createNetClient();</span><br><span class="line"></span><br><span class="line">netClient.connect(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>, res -&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Connected!&quot;</span>);</span><br><span class="line">		NetSocket socket = res.result();</span><br><span class="line">		socket.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Failed to connect: &quot;</span> + res.cause().getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Logging-network-activity"><a href="#Logging-network-activity" class="headerlink" title="Logging network activity"></a>Logging network activity</h5><p>对于服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().setLogActivity(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>对于客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetClientOptions options = <span class="keyword">new</span> NetClientOptions().setLogActivity(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">NetClient client = vertx.createNetClient(options);</span><br></pre></td></tr></table></figure>

<p>打印如下：</p>
<p>![](/Vert.x系列1：Vert.x Core/network-log.png)</p>
<p>默认是以二进制格式输出的，但是可以设置日志数据Format的格式，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions()</span><br><span class="line">  .setLogActivity(<span class="keyword">true</span>)</span><br><span class="line">  .setActivityLogDataFormat(ByteBufFormat.SIMPLE);</span><br><span class="line"></span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>这样的话，打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[id: 0x9ef973b7, L:&#x2F;127.0.0.1:1234 - R:&#x2F;127.0.0.1:59695] REGISTERED</span><br><span class="line">[id: 0x9ef973b7, L:&#x2F;127.0.0.1:1234 - R:&#x2F;127.0.0.1:59695] ACTIVE</span><br><span class="line">[id: 0x9ef973b7, L:&#x2F;127.0.0.1:1234 - R:&#x2F;127.0.0.1:59695] READ: 1B</span><br><span class="line">[id: 0x9ef973b7, L:&#x2F;127.0.0.1:1234 - R:&#x2F;127.0.0.1:59695] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p><code>READ: 1B</code>：表示读取的字节数。</p>
<p>但是需要注意的是：</p>
<ul>
<li>网络日志打印是netty提供的功能</li>
<li>不能用于生产环境</li>
</ul>
<h5 id="Specifying-key-certificate-for-the-server"><a href="#Specifying-key-certificate-for-the-server" class="headerlink" title="Specifying key/certificate for the server"></a>Specifying key/certificate for the server</h5><p>如果要开启<code>ssl</code>，需要设置：<code>setSsl(true)</code>，还需要设置证书/密钥：</p>
<p>方式1（使用KeyStore）：</p>
<blockquote>
<p>可以使用java自带的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/technotes/tools/solaris/keytool.html">keytool</a>工具来生成</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setKeyStoreOptions(</span><br><span class="line">  <span class="keyword">new</span> JksOptions().</span><br><span class="line">    setPath(<span class="string">&quot;/path/to/your/server-keystore.jks&quot;</span>).</span><br><span class="line">    setPassword(<span class="string">&quot;password-of-your-keystore&quot;</span>)</span><br><span class="line">);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>或者可以通过buffer的方式设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">&quot;/path/to/your/server-keystore.jks&quot;</span>);</span><br><span class="line">JksOptions jksOptions = <span class="keyword">new</span> JksOptions().</span><br><span class="line">  setValue(myKeyStoreAsABuffer).</span><br><span class="line">  setPassword(<span class="string">&quot;password-of-your-keystore&quot;</span>);</span><br><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().</span><br><span class="line">  setSsl(<span class="keyword">true</span>).</span><br><span class="line">  setKeyStoreOptions(jksOptions);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>方式2（使用PKCS#12证书，后缀名通常为<code>.pfx</code>或者<code>.p12</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setPfxKeyCertOptions(</span><br><span class="line">  <span class="keyword">new</span> PfxOptions().</span><br><span class="line">    setPath(<span class="string">&quot;/path/to/your/server-keystore.pfx&quot;</span>).</span><br><span class="line">    setPassword(<span class="string">&quot;password-of-your-keystore&quot;</span>)</span><br><span class="line">);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>或者可以通过buffer的方式设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer myKeyStoreAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">&quot;/path/to/your/server-keystore.pfx&quot;</span>);</span><br><span class="line">PfxOptions pfxOptions = <span class="keyword">new</span> PfxOptions().</span><br><span class="line">  setValue(myKeyStoreAsABuffer).</span><br><span class="line">  setPassword(<span class="string">&quot;password-of-your-keystore&quot;</span>);</span><br><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().</span><br><span class="line">  setSsl(<span class="keyword">true</span>).</span><br><span class="line">  setPfxKeyCertOptions(pfxOptions);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>方式3（使用<code>.pem</code>证书）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().setSsl(<span class="keyword">true</span>).setPemKeyCertOptions(</span><br><span class="line">  <span class="keyword">new</span> PemKeyCertOptions().</span><br><span class="line">    setKeyPath(<span class="string">&quot;/path/to/your/server-key.pem&quot;</span>).</span><br><span class="line">    setCertPath(<span class="string">&quot;/path/to/your/server-cert.pem&quot;</span>)</span><br><span class="line">);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<p>或者可以通过buffer的方式设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer myKeyAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">&quot;/path/to/your/server-key.pem&quot;</span>);</span><br><span class="line">Buffer myCertAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">&quot;/path/to/your/server-cert.pem&quot;</span>);</span><br><span class="line">PemKeyCertOptions pemOptions = <span class="keyword">new</span> PemKeyCertOptions().</span><br><span class="line">  setKeyValue(myKeyAsABuffer).</span><br><span class="line">  setCertValue(myCertAsABuffer);</span><br><span class="line">NetServerOptions options = <span class="keyword">new</span> NetServerOptions().</span><br><span class="line">  setSsl(<span class="keyword">true</span>).</span><br><span class="line">  setPemKeyCertOptions(pemOptions);</span><br><span class="line">NetServer server = vertx.createNetServer(options);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上的操作在客户端可以找到对应的设置，不再赘述</p>
</blockquote>
<h5 id="Self-signed-certificates-for-testing-and-development-purposes"><a href="#Self-signed-certificates-for-testing-and-development-purposes" class="headerlink" title="Self-signed certificates for testing and development purposes"></a>Self-signed certificates for testing and development purposes</h5><p>如果我们自己在本地玩的时候，可以使用<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/net/SelfSignedCertificate.html">SelfSignedCertificate</a>，可用于提供自签名PEM证书，并可以提供 <a target="_blank" rel="noopener" href="http://vertx.io/docs/apidocs/io/vertx/core/net/KeyCertOptions.html"><code>KeyCertOptions</code></a>和 <a target="_blank" rel="noopener" href="http://vertx.io/docs/apidocs/io/vertx/core/net/TrustOptions.html"><code>TrustOptions</code></a> 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SelfSignedCertificate certificate = SelfSignedCertificate.create();</span><br><span class="line"></span><br><span class="line">NetServerOptions serverOptions = <span class="keyword">new</span> NetServerOptions()</span><br><span class="line">  .setSsl(<span class="keyword">true</span>)</span><br><span class="line">  .setKeyCertOptions(certificate.keyCertOptions())</span><br><span class="line">  .setTrustOptions(certificate.trustOptions());</span><br><span class="line"></span><br><span class="line">vertx.createNetServer(serverOptions)</span><br><span class="line">  .connectHandler(socket -&gt; socket.end(Buffer.buffer(<span class="string">&quot;Hello!&quot;</span>)))</span><br><span class="line">  .listen(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">NetClientOptions clientOptions = <span class="keyword">new</span> NetClientOptions()</span><br><span class="line">  .setSsl(<span class="keyword">true</span>)</span><br><span class="line">  .setKeyCertOptions(certificate.keyCertOptions())</span><br><span class="line">  .setTrustOptions(certificate.trustOptions());</span><br><span class="line"></span><br><span class="line">NetClient client = vertx.createNetClient(clientOptions);</span><br><span class="line">client.connect(<span class="number">1234</span>, <span class="string">&quot;localhost&quot;</span>, ar -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">    ar.result().handler(buffer -&gt; System.out.println(buffer));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;Woops: &quot;</span> + ar.cause().getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我在本地测试（JDK11）的时候，还需要新增一些依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcprov-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcpkix-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcprov-ext-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Revoking-certificate-authorities"><a href="#Revoking-certificate-authorities" class="headerlink" title="Revoking certificate authorities"></a>Revoking certificate authorities</h5><p>可以通过配置证书吊销列表（CRL）来吊销不再被信任的证书机构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetClientOptions options = <span class="keyword">new</span> NetClientOptions().</span><br><span class="line">  setSsl(<span class="keyword">true</span>).</span><br><span class="line">  setTrustStoreOptions(trustOptions).</span><br><span class="line">  addCrlPath(<span class="string">&quot;/path/to/your/crl.pem&quot;</span>);</span><br><span class="line">NetClient client = vertx.createNetClient(options);</span><br></pre></td></tr></table></figure>

<p>也可以使用buffer的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer myCrlAsABuffer = vertx.fileSystem().readFileBlocking(<span class="string">&quot;/path/to/your/crl.pem&quot;</span>);</span><br><span class="line">NetClientOptions options = <span class="keyword">new</span> NetClientOptions().</span><br><span class="line">  setSsl(<span class="keyword">true</span>).</span><br><span class="line">  setTrustStoreOptions(trustOptions).</span><br><span class="line">  addCrlValue(myCrlAsABuffer);</span><br><span class="line">NetClient client = vertx.createNetClient(options);</span><br></pre></td></tr></table></figure>

<h5 id="Using-a-proxy-for-client-connections"><a href="#Using-a-proxy-for-client-connections" class="headerlink" title="Using a proxy for client connections"></a>Using a proxy for client connections</h5><p>NetClient支持HTTP/1.x <em>CONNECT</em>, <em>SOCKS4a</em> 或者 <em>SOCKS5</em>代理。设置方式也很容易：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetClientOptions options = <span class="keyword">new</span> NetClientOptions()</span><br><span class="line">  .setProxyOptions(<span class="keyword">new</span> ProxyOptions().setType(ProxyType.SOCKS5)</span><br><span class="line">    .setHost(<span class="string">&quot;localhost&quot;</span>).setPort(<span class="number">1080</span>)</span><br><span class="line">    .setUsername(<span class="string">&quot;username&quot;</span>).setPassword(<span class="string">&quot;secret&quot;</span>));</span><br><span class="line">NetClient client = vertx.createNetClient(options);</span><br></pre></td></tr></table></figure>

<p>也可以添加不需要代理的host信息，支持通配符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NetClientOptions options = <span class="keyword">new</span> NetClientOptions()</span><br><span class="line">  .setProxyOptions(<span class="keyword">new</span> ProxyOptions().setType(ProxyType.SOCKS5)</span><br><span class="line">    .setHost(<span class="string">&quot;localhost&quot;</span>).setPort(<span class="number">1080</span>)</span><br><span class="line">    .setUsername(<span class="string">&quot;username&quot;</span>).setPassword(<span class="string">&quot;secret&quot;</span>))</span><br><span class="line">  .addNonProxyHost(<span class="string">&quot;*.foo.com&quot;</span>)</span><br><span class="line">  .addNonProxyHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">NetClient client = vertx.createNetClient(options);</span><br></pre></td></tr></table></figure>

<h4 id="Writing-HTTP-servers-and-clients"><a href="#Writing-HTTP-servers-and-clients" class="headerlink" title="Writing HTTP servers and clients"></a>Writing HTTP servers and clients</h4><p>同TCP服务端/客户端一样，在<code>Vert.x</code>中也可以容易的创建HTTP服务端/客户端，<code>Vert.x</code>支持 HTTP/1.0、HTTP/1.1 和 HTTP/2协议。</p>
<h5 id="Creating-an-HTTP-Server"><a href="#Creating-an-HTTP-Server" class="headerlink" title="Creating an HTTP Server"></a>Creating an HTTP Server</h5><p>创建方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServerOptions options = <span class="keyword">new</span> HttpServerOptions().setMaxWebSocketFrameSize(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">HttpServer server = vertx.createHttpServer(options);</span><br></pre></td></tr></table></figure>

<h5 id="Start-the-Server-Listening"><a href="#Start-the-Server-Listening" class="headerlink" title="Start the Server Listening"></a>Start the Server Listening</h5><p>得到一个<code>HttpServer</code>对象后，就可以设置监听得端口和地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServer server = vertx.createHttpServer();</span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="string">&quot;myhost.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认得端口号：80，默认得host：0.0.0.0</p>
</blockquote>
<p>这个监听动作也是异步的，如果想要感知监听的结果，也可以使用handler来接收回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpServer httpServer = vertx.createHttpServer();</span><br><span class="line">httpServer.requestHandler(request -&gt; &#123;</span><br><span class="line">	request.response().end(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>, <span class="string">&quot;localhost&quot;</span>, res -&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span> (res.succeeded()) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Server is now listening!&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Failed to bind!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果没有设置<code>requestHandler</code>，那么<code>listen</code>会报错，参考代码：<code>io.vertx.core.http.impl.HttpServerImpl#listen(io.vertx.core.net.SocketAddress)</code></p>
<h5 id="Getting-notified-of-incoming-requests"><a href="#Getting-notified-of-incoming-requests" class="headerlink" title="Getting notified of incoming requests"></a>Getting notified of incoming requests</h5><p><code>HttpServer</code>可以使用<code>requestHandler</code>来接受和处理请求，也可以参考上一章的例子。</p>
<p>但是需要注意<code>requestHandler</code>被回调的时机，当请求头被读取完毕后就会触发回调。当请求中有body体的时候，<code>requestHandler</code>被回调时，可能还获取不到body体。</p>
<blockquote>
<p> 看<code>requestHandler</code>回调参数也可以知道，<code>request.body()</code>返回的是个Future。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.vertx.core.http.HttpServerRequest#body()</span></span><br><span class="line"><span class="function">Future&lt;Buffer&gt; <span class="title">body</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Reading-Data-from-the-Request-Body"><a href="#Reading-Data-from-the-Request-Body" class="headerlink" title="Reading Data from the Request Body"></a>Reading Data from the Request Body</h5><p>由于body体可能会很大，比如上传文件的场景， 可以使用<code>request.handler()</code>的方法来分批接受body体，每次请求体的一小块数据收到时，该处理器都会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.handler(buffer -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;I have received a chunk of the body of length &quot;</span> + buffer.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们也可以自己组装数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Buffer totalBuffer = Buffer.buffer();</span><br><span class="line"></span><br><span class="line">request.handler(buffer -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;I have received a chunk of the body of length &quot;</span> + buffer.length());</span><br><span class="line">  totalBuffer.appendBuffer(buffer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">request.endHandler(v -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Full body received, length = &quot;</span> + totalBuffer.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以直接使用<code>bodyHandler</code>，即当接受完所有的body体后，该方法会被调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.bodyHandler(totalBuffer -&gt; &#123;</span><br><span class="line">  System.out.println(&quot;Full body received, length &#x3D; &quot; + totalBuffer.length());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Handling-HTML-forms"><a href="#Handling-HTML-forms" class="headerlink" title="Handling HTML forms"></a>Handling HTML forms</h5><p>当要接受表格时，ContentType需要设置成<code>application/x-www-form-urlencoded</code>或者<code>multipart/form-data</code></p>
<p>当ContentType被设置为<code>application/x-www-form-urlencoded</code>时，表单的属性被编码进url中，就可普通的query参数一样。</p>
<p>当ContentType被设置为<code>multipart/form-data</code>时，表单信息会被编码进请求体中，且只有当请求体被完全读取后，它才可用，还包括上传文件的场景。读取方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.requestHandler(request -&gt; &#123;</span><br><span class="line">  <span class="comment">// 这个设置是关键！！！</span></span><br><span class="line">  request.setExpectMultipart(<span class="keyword">true</span>);</span><br><span class="line">  request.endHandler(v -&gt; &#123;</span><br><span class="line">    <span class="comment">// The body has now been fully read, so retrieve the form attributes</span></span><br><span class="line">    MultiMap formAttributes = request.formAttributes();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>表单最大不能超过8192字节，超过时会报错，可以通过<code>setMaxFormAttributeSize</code>方法来重设大小。</p>
<h5 id="Handling-form-file-uploads"><a href="#Handling-form-file-uploads" class="headerlink" title="Handling form file uploads"></a>Handling form file uploads</h5><p><code>Vert.x</code>可以处理以<code>multi-part</code>编码形式上传的的文件，可以设置<code>uploadHandler</code>来接受上传的文件，当服务器每次接收到上传请求时，该处理器将被调用一次。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.requestHandler(request -&gt; &#123;</span><br><span class="line">  request.setExpectMultipart(<span class="keyword">true</span>);</span><br><span class="line">  request.uploadHandler(upload -&gt; &#123;</span><br><span class="line">    <span class="comment">// upload对象是HttpServerFileUpload的一个实例</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Got a file upload &quot;</span> + upload.name());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上传的文件可能很大，<code>Vert.x</code>也提供了分块接受的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.uploadHandler(upload -&gt; &#123;</span><br><span class="line">  upload.handler(chunk -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Received a chunk of the upload of length &quot;</span> + chunk.length());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以把文件直接上传到本地：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.uploadHandler(upload -&gt; &#123;</span><br><span class="line">  upload.streamToFileSystem(<span class="string">&quot;myuploads_directory/&quot;</span> + upload.filename());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Handling-cookies"><a href="#Handling-cookies" class="headerlink" title="Handling cookies"></a>Handling cookies</h5><p>请求中可以使用<code>getCookie()</code>获取单个cookie或者通过<code>cookies()</code>获取所有的cookie；响应中可以使用<code>removeCookie()</code>移除某个cookie或者通过<code>addCookie()</code>来添加某个cookie。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie someCookie = request.getCookie(<span class="string">&quot;mycookie&quot;</span>);</span><br><span class="line">String cookieValue = someCookie.getValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do something with cookie...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a cookie - this will get written back in the response automatically</span></span><br><span class="line">request.response().addCookie(Cookie.cookie(<span class="string">&quot;othercookie&quot;</span>, <span class="string">&quot;somevalue&quot;</span>));</span><br></pre></td></tr></table></figure>

<h5 id="Handling-responses"><a href="#Handling-responses" class="headerlink" title="Handling responses"></a>Handling responses</h5><ul>
<li><p>可以通过<code>request.response()</code>来获取<code>response</code>，类型为<a target="_blank" rel="noopener" href="https://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerResponse.html">HttpServerResponse</a></p>
</li>
<li><p>可以通过<code>HttpServerResponse.setStatusCode()</code>和<code>HttpServerResponse.setStatusMessage()</code>来设置响应码和响应信息（默认的响应码为<code>200</code>，响应信息为<code>ok</code>）</p>
</li>
<li><p>可以通过<code>HttpServerResponse.putHeader()</code>来设置响应头。</p>
</li>
<li><p>可以通过<code>HttpServerResponse.write()</code>来往响应中写内容，但是需要注意的是得设置：<code>HttpServerResponse.setChunked(true)</code>，不然会报错。</p>
</li>
<li><p>可以通过<code>HttpServerResponse.end()</code>来结束一个响应。</p>
</li>
</ul>
<h5 id="Serving-files-directly-from-disk-or-the-classpath"><a href="#Serving-files-directly-from-disk-or-the-classpath" class="headerlink" title="Serving files directly from disk or the classpath"></a>Serving files directly from disk or the classpath</h5><p>如果想要提供文件下载，也是很方便，直接使用<code>HttpServerResponse.sendFile()</code>方法即可，而且和kafka的零拷贝类似，是不用进过用户态的，效率非常高。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">anthow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xhanthow.github.io/2022/03/09/Vert.x系列1：Vert.x Core/">https://xhanthow.github.io/2022/03/09/Vert.x系列1：Vert.x Core/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vert-x/">Vert.x</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/05/12/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%951%EF%BC%9AHttp%20Trailer/"><i class="fa fa-chevron-left">  </i><span>刨根问底(1)：Http Trailer</span></a></div><div class="next-post pull-right"><a href="/2022/03/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BB%8E%E9%9C%80%E6%B1%82%E5%88%B0%E6%9E%B6%E6%9E%84%E3%80%8B/"><span>读书笔记--《架构基础：从需求到架构》</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'ea5d90c812bbb7e1b433',
  clientSecret: 'b8b9e07d66f80cf692eab1e53cc654b48526ed38',
  repo: 'xhanthow.github.io',
  owner: 'xhanthow',
  admin: 'xhanthow',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2022 By anthow</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>